<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Gallery Dashboard</title>
<link rel="icon" href="," />
<style>
:root {
--bg: #c66e97;
--panel: #54dbb5;
--soft: #a53ac5;
--accent: #a0f0d9;
--accent-2: #00c9a7;
--text: #00c9a7;
--muted: #9ae9d7;
}
*{box-sizing:border-box} html,body{height:100%;overflow-x:hidden}
body{margin:0;background:linear-gradient(180deg,var(--bg),#0b0e1e 60%);color:var(--text);font:14px/1.4 system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
header{position:sticky;top:0;z-index:5;background:rgba(15,18,38,.8);backdrop-filter:blur(8px);border-bottom:1px solid #1f2350}
.wrap{max-width:1100px;margin:0 auto;padding:12px 12px 8px}
h1{margin:0;font-size:23px;letter-spacing:.3px;display:flex;align-items:center;gap:12px;justify-content:center;position:relative}
.back-btn-container {
    position: absolute;
    left: 12px;
    top: 4px;
    z-index: 10;
}
.toolbar{display:flex;gap:8px;flex-wrap:wrap;margin-top:6px}
.toolbar-group{display:flex;gap:8px;flex-wrap:wrap}
button,.file-label{appearance:none;border:1px solid #2b2f66;background:linear-gradient(180deg,#1b2050,#151a44);color:var(--text);padding:10px 12px;border-radius:14px;cursor:pointer;transition:.2s;box-shadow:0 1px 0 #2a2f62 inset,0 6px 16px rgba(0,0,0,.2);min-height:44px}
button:hover,.file-label:hover{transform:translateY(-1px);border-color:#3940a5} button:disabled{opacity:.5;cursor:not-allowed}
.file-label{display:inline-flex;align-items:center;gap:6px} input[type=file]{display:none}
.stats{margin-left:auto;color:var(--muted);display:flex;align-items:center;gap:10px;flex-wrap:wrap;font-size:13px}
.stats.hidden{display:none}
main{max-width:1100px;margin:12px auto 80px;padding:0 12px}
.dropzone{border:2px dashed #2c326e;border-radius:16px;padding:20px;text-align:center;color:var(--muted);background:rgba(124,140,255,.06);font-size:14px}
.dropzone.dragover{border-color:var(--accent);background:rgba(124,140,255,.12);color:var(--text)}
.grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(140px,1fr));gap:12px;margin-top:12px}
.album-list {
display: flex;
flex-direction: column;
gap: 12px;
margin-top: 16px;
}
.album-list-item {
display: flex;
align-items: center;
gap: 16px;
padding: 16px;
background: linear-gradient(135deg, #161a36, #2a1e5a);
border: 1px solid #22265a;
border-radius: 14px;
cursor: pointer;
}
.album-list-item:hover {
background: linear-gradient(135deg, #1a1f3d, #2d215d);
}
.album-info {
flex: 1;
min-width: 0;
}
.album-name-list {
font-size: 18px;
font-weight: bold;
margin: 0;
color: var(--text);
overflow: hidden;
text-overflow: ellipsis;
white-space: nowrap;
}
.album-actions {
display: flex;
gap: 8px;
}
.album-action-btn {
width: 36px;
height: 36px;
border-radius: 50%;
background: rgba(0,0,0,0.3);
border: 1px solid #2b2f66;
color: var(--text);
display: flex;
align-items: center;
justify-content: center;
cursor: pointer;
transition: background 0.2s;
}
.album-action-btn:hover {
background: rgba(255,255,255,0.1);
}
.card{position:relative;background:linear-gradient(180deg,#161a36,#121638);border:1px solid #22265a;border-radius:14px;overflow:hidden}
.thumb{width:100%;height:110px;object-fit:cover;background:#0a0d20;display:block}
.meta{display:flex;justify-content:space-between;align-items:center;padding:6px 8px;color:var(--muted);font-size:11px}
.name{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;max-width:70%}
.badge{border:1px solid #2b2f66;border-radius:999px;padding:1px 6px;font-size:10px}
.select{position:absolute;top:6px;left:6px;background:rgba(0,0,0,.5);backdrop-filter:blur(4px);padding:5px;border-radius:8px}
.actions{display:flex;gap:6px;padding:6px;border-top:1px solid #22265a}
.actions button{flex:1;padding:6px;border-radius:8px;min-height:36px;font-size:12px}
.empty{color:var(--muted);text-align:center;padding:24px;font-size:15px}
footer{position:fixed;inset:auto 0 0 0;background:rgba(15,18,38,.9);backdrop-filter:blur(8px);border-top:1px solid #1f2350}
.footer-wrap{max-width:1100px;margin:0 auto;padding:8px 12px;display:flex;gap:8px;align-items:center}
.dialog-backdrop::after{content:'';position:absolute;top:0;left:0;width:100%;height:100%;background:#00000040;z-index:-1}
dialog{border:none;border-radius:16px;padding:0;max-width:95vw;background:#0e1333;color:var(--text);box-shadow:0 30px 80px rgba(0,0,0,.5);position:relative}
.modal-head{padding:10px 14px;border-bottom:1px solid #22265a;display:flex;justify-content:space-between;align-items:center}
.modal-body{padding:10px} .modal-body img{max-width:95vw;max-height:70vh;display:block}
.close-x{background:transparent;border:0;color:var(--muted);font-size:20px;cursor:pointer}
.hidden{display:none}
.dashboard-header{text-align:center;margin-bottom:20px;padding:16px 0;}
.dashboard-title{font-size:24px;font-weight:bold;margin:0;color:var(--accent);}
.dashboard-subtitle{color:var(--muted);margin-top:4px;font-size:14px}
.dashboard-meta{color:var(--muted);margin-top:8px;font-size:13px}
.dashboard-actions{display:flex;gap:10px;justify-content:center;margin-top:14px;flex-wrap:wrap}
.back-btn {
background: rgba(27,32,80,0.5);
border: 1px solid #2b2f66;
padding: 6px 12px;
border-radius: 10px;
display: flex;
align-items: center;
gap: 6px;
cursor: pointer;
text-decoration: none;
color: var(--text);
font-weight: 500;
white-space: nowrap;
}
.back-btn:hover {
background: rgba(27,32,80,0.7);
}
#progressDialog {
max-width: 500px;
}
.progress-header {
font-weight: bold;
margin-bottom: 8px;
color: var(--accent);
}
.progress-bar-container {
height: 12px;
background: #1f2350;
border-radius: 6px;
overflow: hidden;
margin: 12px 0;
}
.progress-bar {
height: 100%;
background: var(--accent-2);
width: 0%;
transition: width 0.2s ease;
}
.progress-info {
font-size: 13px;
color: var(--muted);
margin: 6px 0;
min-height: 1.4em;
}
.progress-actions {
display: flex;
gap: 8px;
margin-top: 16px;
}
.progress-actions button {
flex: 1;
}
</style>
</head>
<body>
<header>
<div class="wrap">
<h1 id="pageTitle">
<span id="pageTitleCenter"></span>
</h1>
<div class="back-btn-container" id="backBtnContainer"></div>
<div class="toolbar">
<div class="toolbar-group" id="dashboardActions">
<button id="newAlbumBtn">üìÅ Create Album</button>
<button id="refreshCacheBtn">üîÑ Refresh Cache</button>
</div>
<div class="toolbar-group" id="albumActionsGroup" style="display:none">
<label class="file-label" title="Choose images">
<input id="fileInput" type="file" accept="image/*" multiple />
üì§ Upload
</label>
<label class="file-label" title="Import to current album (.json)">
<input id="importInput" type="file" accept="application/json" />
üì• Import
</label>
<button id="exportSel" disabled>üíæ Export Sel</button>
<button id="exportAll" disabled>üíæ Export All</button>
<button id="selectAll" disabled>‚òëÔ∏è Select All</button>
<button id="clearSel" disabled>üóëÔ∏è Del Sel</button>
<button id="clearAll" disabled>üßπ Clear All</button>
</div>
<div class="stats" id="stats">0 items ¬∑ 0 MB</div>
</div>
</div>
</header>
<main>
<div id="dashboardView">
<div class="dashboard-header">
<div class="dashboard-meta" id="dashboardMeta">Loading...</div>
<div class="dashboard-actions">
<button id="backupAllBtn" style="background:#00c9a7;color:#0a0d20">üíæ Backup All (ZIP)</button>
<label class="file-label" title="Restore all albums from ZIP">
<input id="restoreAllInput" type="file" accept=".zip,application/zip" />
üì• Restore All (ZIP)
</label>
</div>
</div>
<div id="noAlbums" class="empty">No albums yet. Create your first album ‚ú®</div>
<div id="albumList" class="album-list"></div>
</div>
<div id="galleryView" class="hidden">
<div id="dropzone" class="dropzone hidden">Drag & drop images/GIFs here, or use Upload above.</div>
<div id="gallery" class="grid" aria-live="polite"></div>
<div id="emptyState" class="empty hidden">No images yet. Upload or drop some to get started ‚ú®</div>
</div>
</main>
<dialog id="viewer">
<div class="modal-head">
<div id="viewerName">Preview</div>
<button class="close-x" onclick="viewer.close()">√ó</button>
</div>
<div class="modal-body"><img id="viewerImg" alt="Preview" /></div>
</dialog>
<dialog id="albumDialog">
<div class="modal-head">
<div>Create New Album</div>
<button class="close-x" onclick="albumDialog.close()">√ó</button>
</div>
<div class="modal-body">
<div class="form-group">
<label for="albumName">Album Name</label>
<input type="text" id="albumName" placeholder="Enter album name..." maxlength="50">
</div>
<div style="display:flex;gap:10px;margin-top:16px">
<button id="createAlbumBtn" style="flex:1">Create Album</button>
<button onclick="albumDialog.close()" style="flex:1;background:#2b2f66">Cancel</button>
</div>
</div>
</dialog>
<dialog id="albumActionsDialog">
<div class="modal-head">
<div id="albumActionsTitle">Album Actions</div>
<button class="close-x" onclick="albumActionsDialog.close()">√ó</button>
</div>
<div class="modal-body" style="padding:16px">
<div class="form-group">
<label>Backup Options</label>
<div style="display:flex;gap:8px;margin-top:8px;flex-wrap:wrap">
<button id="exportAlbum" style="flex:1;min-width:160px">üíæ Export This Album</button>
</div>
</div>
<div class="form-group" style="margin-top:16px">
<label>Restore Options</label>
<div style="display:flex;gap:8px;margin-top:8px;flex-wrap:wrap">
<label class="file-label" style="flex:1;min-width:160px">
<input id="importAlbumInput" type="file" accept="application/json" />
üì• Import to This Album
</label>
</div>
</div>
<div class="form-group" style="margin-top:16px">
<label>Danger Zone</label>
<div style="display:flex;gap:8px;margin-top:8px;">
<button id="deleteAlbum" style="flex:1;background:#d9534f;border-color:#c9302c">üóëÔ∏è Delete Album</button>
</div>
</div>
</div>
</dialog>
<dialog id="progressDialog">
<div class="modal-head">
<div id="progressTitle">Backup Progress</div>
<button class="close-x" id="cancelProgressBtn">√ó</button>
</div>
<div class="modal-body">
<div class="progress-header" id="progressHeader">Starting‚Ä¶</div>
<div class="progress-bar-container"><div class="progress-bar" id="progressBar"></div></div>
<div class="progress-info" id="progressInfo">Preparing‚Ä¶</div>
<div class="progress-actions">
<button id="closeProgressBtn" style="background:#2b2f66">Close</button>
</div>
</div>
</dialog>
<script src="https://cdn.jsdelivr.net/npm/@zip.js/zip.js@2.7.46/dist/zip.min.js"></script>
<script>
const DB_NAME = 'page1';
const STORE = 'images';
const ALBUM_STORE = 'albums';
const META = 'meta';
const DB_VERSION = 2;
const PBKDF2_ITERATIONS = 200000;
const SALT_KEY = 'salt';
const ENC_ALGO = { name: 'AES-GCM', length: 256 };
let cryptoKey = null;
let salt = null;

let db;

function openDB(){
return new Promise((resolve,reject)=>{
const req = indexedDB.open(DB_NAME, DB_VERSION);
req.onupgradeneeded = (event) => {
const d = event.target.result;
if(!d.objectStoreNames.contains(STORE)){
const os = d.createObjectStore(STORE,{keyPath:'id'});
os.createIndex('by_name','name',{unique:false});
os.createIndex('by_album','albumId',{unique:false});
}
if(!d.objectStoreNames.contains(ALBUM_STORE)){
const albumOS = d.createObjectStore(ALBUM_STORE,{keyPath:'id'});
albumOS.createIndex('by_name','name',{unique:false});
}
if(!d.objectStoreNames.contains(META)){
d.createObjectStore(META, { keyPath: 'k' });
}
};
req.onsuccess = async () => {
db = req.result;
const txMeta = db.transaction([META], 'readonly');
const storeMeta = txMeta.objectStore(META);
const getMigReq = storeMeta.get('migrated_v2');

getMigReq.onsuccess = () => {
    if (!getMigReq.result) {
        console.log('Running post-upgrade migration...');
        const tx = db.transaction([STORE, META], 'readwrite');
        const store = tx.objectStore(STORE);
        const getAllReq = store.getAll();
        
        getAllReq.onsuccess = () => {
            const images = getAllReq.result || [];
            images.forEach(img => {
                if (img.albumId === undefined) {
                    img.albumId = 'default';
                    store.put(img);
                }
            });
            tx.objectStore(META).put({k: 'migrated_v2', v: true});
        };
        tx.oncomplete = () => {
            console.log('Migration committed.');
            resolve(db);
        };
        tx.onerror = (e) => reject(e);
    } else {
        resolve(db);
    }
};
};
req.onerror = () => reject(req.error);
});
}

function txObjectStore(mode='readonly'){ return db.transaction([STORE], mode).objectStore(STORE); }
function txAlbumStore(mode='readonly'){ return db.transaction([ALBUM_STORE], mode).objectStore(ALBUM_STORE); }
function txMetaStore(mode='readonly'){ return db.transaction([META], mode).objectStore(META); }
function putImageRecord(record){ return new Promise((res,rej)=>{ const r = txObjectStore('readwrite').put(record); r.onsuccess=()=>res(); r.onerror=()=>rej(r.error) }); }
function putAlbumRecord(record){ return new Promise((res,rej)=>{ const r = txAlbumStore('readwrite').put(record); r.onsuccess=()=>res(); r.onerror=()=>rej(r.error) }); }
function deleteImageRecord(id){ return new Promise((res,rej)=>{ const r = txObjectStore('readwrite').delete(id); r.onsuccess=()=>res(); r.onerror=()=>rej(r.error) }); }
function deleteAlbumRecord(id){ return new Promise((res,rej)=>{ const r = txAlbumStore('readwrite').delete(id); r.onsuccess=()=>res(); r.onerror=()=>rej(r.error) }); }
function getImageRecordsByAlbum(albumId){
return new Promise((res,rej)=>{
const store = txObjectStore('readonly');
if (store.indexNames.contains('by_album')) {
const idx = store.index('by_album');
const req = idx.getAll(IDBKeyRange.only(albumId));
req.onsuccess = () => res(req.result || []);
req.onerror = () => rej(req.error);
} else {
const req = store.getAll();
req.onsuccess = () => {
const all = req.result || [];
const filtered = all.filter(img => img.albumId === albumId);
res(filtered);
};
req.onerror = () => rej(req.error);
}
});
}
function getAllRecords(){ return new Promise((res,rej)=>{ const r = txObjectStore('readonly').getAll(); r.onsuccess=()=>res(r.result||[]); r.onerror=()=>rej(r.error) }); }
function getAllAlbums(){ return new Promise((res,rej)=>{ const r = txAlbumStore('readonly').getAll(); r.onsuccess=()=>res(r.result||[]); r.onerror=()=>rej(r.error) }); }
function getManyRecords(ids){
const store = txObjectStore('readonly');
return Promise.all(ids.map(id=>new Promise((res,rej)=>{
const r = store.get(id);
r.onsuccess=()=>res(r.result);
r.onerror=()=>rej(r.error)
})));
}
function metaGet(key){ return new Promise((res,rej)=>{ const r = txMetaStore('readonly').get(key); r.onsuccess=()=>res(r.result? r.result.v : undefined); r.onerror=()=>rej(r.error) }); }
function metaPut(key,value){ return new Promise((res,rej)=>{ const r = txMetaStore('readwrite').put({k:key,v:value}); r.onsuccess=()=>res(); r.onerror=()=>rej(r.error) }); }

const $ = sel => document.querySelector(sel);
const fmtBytes = n => (n? (n/1024/1024).toFixed(2):'0.00')+ ' MB';
const uid = () => crypto.randomUUID ? crypto.randomUUID() : (Date.now()+Math.random()).toString(36);
async function blobToArrayBuffer(blob){ return await blob.arrayBuffer(); }
function arrayBufferToBlob(ab, type){ return new Blob([ab], { type: type || 'application/octet-stream' }); }

async function deriveKeyFromPassword(password, saltBytes){
const enc = new TextEncoder();
const keyMaterial = await crypto.subtle.importKey('raw', enc.encode(password), { name: 'PBKDF2' }, false, ['deriveKey']);
const derived = await crypto.subtle.deriveKey(
{ name: 'PBKDF2', salt: saltBytes, iterations: PBKDF2_ITERATIONS, hash: 'SHA-256' },
keyMaterial,
ENC_ALGO,
false,
['encrypt','decrypt']
);
return derived;
}
async function ensureSaltAndKey(password){
const metaSalt = await metaGet(SALT_KEY);
if(metaSalt){
salt = Uint8Array.from(metaSalt);
}else{
const s = crypto.getRandomValues(new Uint8Array(16));
salt = s;
await metaPut(SALT_KEY, Array.from(s));
}
cryptoKey = await deriveKeyFromPassword(password, salt);
}
async function encryptArrayBuffer(ab){
const iv = crypto.getRandomValues(new Uint8Array(12));
const cipher = await crypto.subtle.encrypt({ name:'AES-GCM', iv }, cryptoKey, ab);
return { iv: Array.from(iv), cipher: cipher };
}
async function decryptToArrayBuffer(ivArr, cipherAB){
const iv = new Uint8Array(ivArr);
const plain = await crypto.subtle.decrypt({ name:'AES-GCM', iv }, cryptoKey, cipherAB);
return plain;
}

const fileInput = $('#fileInput');
const importInput = $('#importInput');
const gallery = $('#gallery');
const dropzone = $('#dropzone');
const emptyState = $('#emptyState');
const stats = $('#stats');
const viewer = $('#viewer');
const viewerImg = $('#viewerImg');
const viewerName = $('#viewerName');
const dashboardView = $('#dashboardView');
const galleryView = $('#galleryView');
const albumList = $('#albumList');
const noAlbums = $('#noAlbums');
const newAlbumBtn = $('#newAlbumBtn');
const albumDialog = $('#albumDialog');
const albumNameInput = $('#albumName');
const createAlbumBtn = $('#createAlbumBtn');
const albumActionsDialog = $('#albumActionsDialog');
const albumActionsTitle = $('#albumActionsTitle');
const exportAlbumBtn = $('#exportAlbum');
const importAlbumInput = $('#importAlbumInput');
const deleteAlbumBtn = $('#deleteAlbum');
const backupAllBtn = $('#backupAllBtn');
const refreshCacheBtn = $('#refreshCacheBtn');
const restoreAllInput = $('#restoreAllInput');
const backBtnContainer = $('#backBtnContainer');
const pageTitleCenter = $('#pageTitleCenter');
const pageTitle = $('#pageTitle');
const dashboardActions = $('#dashboardActions');
const albumActionsGroup = $('#albumActionsGroup');
const exportSelBtn = $('#exportSel');
const exportAllBtn = $('#exportAll');
const selectAllBtn = $('#selectAll');
const clearSelBtn = $('#clearSel');
const clearAllBtn = $('#clearAll');
const progressDialog = $('#progressDialog');
const progressTitle = $('#progressTitle');
const progressHeader = $('#progressHeader');
const progressBar = $('#progressBar');
const progressInfo = $('#progressInfo');
const cancelProgressBtn = $('#cancelProgressBtn');
const closeProgressBtn = $('#closeProgressBtn');
let cancelToken = { cancelled: false };
let selections = new Set();
let currentAlbumId = 'default';
let albums = [];
let currentActionAlbum = null;
let albumImages = [];

async function ensureDefaultAlbum() {
try {
const tx = db.transaction([ALBUM_STORE], 'readonly');
const req = tx.objectStore(ALBUM_STORE).get('default');
return new Promise((resolve) => {
req.onsuccess = () => {
if (!req.result) {
const defaultAlbumRecord = {
id: 'default',
name: 'Default',
createdAt: Date.now(),
imageCount: 0
};
putAlbumRecord(defaultAlbumRecord).then(() => resolve(true)).catch(() => resolve(false));
} else {
resolve(true);
}
};
req.onerror = () => {
const defaultAlbumRecord = {
id: 'default',
name: 'Default',
createdAt: Date.now(),
imageCount: 0
};
putAlbumRecord(defaultAlbumRecord).then(() => resolve(true)).catch(() => resolve(false));
};
});
} catch (e) {
console.warn('Error ensuring default album:', e);
return false;
}
}
async function createAlbum(name) {
if (!name || name.trim() === '') {
alert('Please enter a valid album name');
return;
}
const albumId = uid();
const albumRecord = {
id: albumId,
name: name.trim(),
createdAt: Date.now(),
imageCount: 0
};
await putAlbumRecord(albumRecord);
await refreshDashboard();
albumDialog.close();
albumNameInput.value = '';
}
async function deleteAlbum(albumId) {
if (albumId === 'default') {
alert('Cannot delete the default album');
return;
}
const imagesToDelete = await getImageRecordsByAlbum(albumId);
for (const img of imagesToDelete) {
await deleteImageRecord(img.id);
}
await deleteAlbumRecord(albumId);
if (currentAlbumId === albumId) {
switchToDashboard();
} else {
await refreshDashboard();
}
}
function openAlbumActions(album) {
currentActionAlbum = album;
albumActionsTitle.textContent = `Album: ${album.name}`;
albumActionsDialog.showModal();
}

async function refreshAlbumCache() {
try {
const allAlbums = await getAllAlbums();
const userAlbums = allAlbums.filter(a => a.id !== 'default');
if (userAlbums.length === 0) {
await metaPut('all-album-cache', {
version: 1,
lastUpdated: Date.now(),
albums: []
});
return;
}
const albumIds = userAlbums.map(a => a.id);
const requests = albumIds.map(albumId => getImageRecordsByAlbum(albumId));
const results = await Promise.all(requests);
const albumsWithCounts = userAlbums.map((album, index) => ({
id: album.id,
name: album.name,
createdAt: album.createdAt || Date.now(),
imageCount: results[index] ? results[index].length : 0
}));
const cacheData = {
version: 1,
lastUpdated: Date.now(),
albums: albumsWithCounts
};
await metaPut('all-album-cache', cacheData);
return cacheData;
} catch (e) {
console.error('Failed to refresh cache', e);
throw e;
}
}

async function refreshDashboard() {
let userAlbums = [];
try {
const cacheData = await metaGet('all-album-cache');
if (cacheData && cacheData.version === 1 && Array.isArray(cacheData.albums)) {
userAlbums = cacheData.albums;
albums = await getAllAlbums();
} else {
throw new Error('No valid cache');
}
} catch (e) {
try {
albums = await getAllAlbums();
const allUserAlbums = albums.filter(a => a.id !== 'default');
const albumIds = allUserAlbums.map(a => a.id);
const requests = albumIds.map(albumId => getImageRecordsByAlbum(albumId));
const results = await Promise.all(requests);
userAlbums = allUserAlbums.map((album, index) => ({
id: album.id,
name: album.name,
createdAt: album.createdAt || Date.now(),
imageCount: results[index] ? results[index].length : 0
}));
} catch (err) {
albums = [];
userAlbums = [];
}
}
// SORT ALPHABETICALLY (A-Z)
userAlbums.sort((a, b) => a.name.localeCompare(b.name, undefined, {sensitivity: 'base'}));

const totalAlbums = userAlbums.length;
const albumWord = totalAlbums === 1 ? 'album' : 'albums';
$('#dashboardMeta').textContent = totalAlbums > 0 ? `${totalAlbums} ${albumWord}` : 'No albums';

albumList.innerHTML = '';
noAlbums.classList.toggle('hidden', userAlbums.length > 0);

if (userAlbums.length === 0) return;

for (const album of userAlbums) {
const listItem = document.createElement('div');
listItem.className = 'album-list-item';
listItem.dataset.albumId = album.id;
listItem.innerHTML = `
<div class="album-info">
<div class="album-name-list">${album.name}</div>
</div>
<div class="album-actions">
<button class="album-action-btn" data-action="manage" title="Manage Album">‚öôÔ∏è</button>
</div>
`;
listItem.querySelector('[data-action="manage"]').addEventListener('click', (e) => {
e.stopPropagation();
openAlbumActions(album);
});
listItem.addEventListener('click', () => {
switchToAlbum(album.id);
});
albumList.appendChild(listItem);
}
}

async function refreshGalleryView() {
try {
albumImages = await getImageRecordsByAlbum(currentAlbumId);
} catch (e) {
console.error('Failed to get images for album', currentAlbumId, e);
albumImages = [];
}
gallery.innerHTML = '';
let albumBytes = 0;
albumImages.forEach(it => albumBytes += (it.size || 0));
stats.textContent = `${albumImages.length} items ¬∑ ${fmtBytes(albumBytes)}`;
const currentAlbum = albums.find(a => a.id === currentAlbumId) || { name: 'Default' };
pageTitleCenter.textContent = currentAlbum.name;
const hasImages = albumImages.length > 0;
exportAllBtn.disabled = !hasImages;
clearAllBtn.disabled = !hasImages;
selectAllBtn.disabled = !hasImages;
emptyState.classList.toggle('hidden', albumImages.length !== 0);
dropzone.classList.toggle('hidden', currentAlbumId !== 'default');
albumImages.sort((a,b)=> (b.addedAt||0) - (a.addedAt||0));
for(const it of albumImages){
let blob;
try{
const plainAB = await decryptToArrayBuffer(it.iv, it.cipher);
blob = arrayBufferToBlob(plainAB, it.type || 'image/*');
}catch(err){
console.error('Decryption failed for', it.id, err);
const cardErr = document.createElement('div');
cardErr.className = 'card';
cardErr.innerHTML = `<div style="padding:12px;color:var(--muted);font-size:13px">Unable to decrypt "${it.name}"</div>`;
gallery.appendChild(cardErr);
continue;
}
const url = URL.createObjectURL(blob);
const card = document.createElement('div');
card.className = 'card';
card.innerHTML = `
<div class="select"><input type="checkbox" aria-label="Select ${it.name}" ${selections.has(it.id)?'checked':''}></div>
<img class="thumb" src="${url}" alt="${it.name}">
<div class="meta">
<div class="name" title="${it.name}">${it.name}</div>
<div class="badge">${(it.type||'image').split('/').pop().toUpperCase()}</div>
</div>
<div class="actions">
<button data-act="view">View</button>
<button data-act="del">Del</button>
<button data-act="dl">DL</button>
</div>
`;
const cb = card.querySelector('input[type=checkbox]');
cb.addEventListener('change', () => {
if(cb.checked) selections.add(it.id); else selections.delete(it.id);
updateSelectionButtons();
});
card.querySelector('[data-act=view]').addEventListener('click',()=>{
viewerImg.src = url; viewerName.textContent = it.name; viewer.showModal();
});
card.querySelector('[data-act=del]').addEventListener('click', async()=>{
if(confirm(`Delete "${it.name}"?`)){
await deleteImageRecord(it.id);
selections.delete(it.id);
refreshGalleryView();
}
});
card.querySelector('[data-act=dl]').addEventListener('click',()=>{
const a = document.createElement('a');
a.href = url; a.download = it.name || 'image'; a.click();
});
card.querySelector('.thumb').addEventListener('click',()=>{
cb.checked=!cb.checked;
cb.dispatchEvent(new Event('change'));
});
gallery.appendChild(card);
}
updateSelectionButtons();
}
function updateSelectionButtons(){
const hasSel = selections.size>0;
exportSelBtn.disabled = !hasSel;
clearSelBtn.disabled = !hasSel;
}

async function switchToDashboard() {
dashboardView.classList.remove('hidden');
galleryView.classList.add('hidden');
backBtnContainer.innerHTML = '';
pageTitleCenter.innerHTML = 'Gallery Dashboard <span style="color:var(--accent)">üìÅ</span>';
dashboardActions.style.display = 'flex';
albumActionsGroup.style.display = 'none';
selections.clear();
stats.classList.add('hidden');
await refreshDashboard();
}

function switchToAlbum(albumId) {
currentAlbumId = albumId;
dashboardView.classList.add('hidden');
galleryView.classList.remove('hidden');
const album = albums.find(a => a.id === albumId) || { name: 'Default' };
backBtnContainer.innerHTML = `<a href="#" class="back-btn" id="backToDashboard">‚Üê Back</a>`;
backBtnContainer.querySelector('#backToDashboard').addEventListener('click', (e) => {
e.preventDefault();
switchToDashboard();
});
pageTitleCenter.textContent = album.name;
refreshGalleryView();
dashboardActions.style.display = 'none';
albumActionsGroup.style.display = 'flex';
stats.classList.remove('hidden');
}

async function exportByIds(ids, albumName = null){
const records = (await getManyRecords(ids)).filter(Boolean);
const images = [];
for(const r of records){
try{
const plainAB = await decryptToArrayBuffer(r.iv, r.cipher);
const blob = arrayBufferToBlob(plainAB, r.type);
const dataURL = await blobToDataURL(blob);
images.push({
id: r.id,
name: r.name,
type: r.type,
size: r.size,
lastModified: r.lastModified,
addedAt: r.addedAt,
dataURL
});
}catch(err){
alert('Failed to decrypt for export. Aborted.');
return;
}
}
const payload = {
version:2,
exportedAt: new Date().toISOString(),
albumId: albumName ? uid() : null,
albumName: albumName,
images
};
const blob = new Blob([JSON.stringify(payload)], {type:'application/json'});
const a = document.createElement('a');
const timestamp = new Date().toISOString().slice(0,19).replace(/[:T]/g,'-');
const filename = albumName
? `gallery1-album-${albumName}-${timestamp}.json`
: `gallery1-export-${timestamp}.json`;
a.href = URL.createObjectURL(blob);
a.download = filename;
a.click();
}
async function exportAlbumById(albumId) {
const album = albums.find(a => a.id === albumId);
if (!album) return;
const images = await getImageRecordsByAlbum(albumId);
if (images.length === 0) {
alert('This album is empty');
return;
}
await exportByIds(images.map(i => i.id), album.name);
}

async function backupAllToZip() {
cancelToken = { cancelled: false };
cancelProgressBtn.style.display = 'block';
closeProgressBtn.style.display = 'none';
const allAlbums = (await getAllAlbums()).filter(a => a.id !== 'default');
const albumsMap = new Map();
for (const album of allAlbums) {
const images = await getImageRecordsByAlbum(album.id);
albumsMap.set(album.id, { album, images });
}
const totalFiles = Array.from(albumsMap.values()).reduce((sum, a) => sum + a.images.length, 0);
if (totalFiles === 0) {
alert('No images to back up.');
return;
}
progressTitle.textContent = 'Backing Up All Albums';
progressHeader.textContent = 'Preparing ZIP‚Ä¶';
progressInfo.textContent = 'Gathering files‚Ä¶';
progressBar.style.width = '0%';
progressDialog.showModal();
zip.configure({ useWebWorkers: false });
try {
const zipWriter = new zip.ZipWriter(new zip.BlobWriter("application/zip"), { bufferedWrite: true });
let processed = 0;
for (const [albumId, { album, images }] of albumsMap) {
if (cancelToken.cancelled) throw new Error('Cancelled by user');
const albumFolder = `${album.name.replace(/[<>:"/\\|?*]/g, '_')}/`;
const usedNames = new Set();
for (const img of images) {
if (cancelToken.cancelled) throw new Error('Cancelled by user');
try {
const plainAB = await decryptToArrayBuffer(img.iv, img.cipher);
const blob = arrayBufferToBlob(plainAB, img.type);
let safeName = img.name.replace(/[<>:"/\\|?*]/g, '_');
if (usedNames.has(safeName)) {
    const nameParts = safeName.split('.');
    const ext = nameParts.length > 1 ? nameParts.pop() : '';
    const base = nameParts.join('.');
    const uniqueId = Math.random().toString(36).substring(2, 6);
    safeName = `${base}_${uniqueId}${ext ? '.' + ext : ''}`;
}
usedNames.add(safeName);
const path = albumFolder + safeName;
await zipWriter.add(path, new zip.BlobReader(blob), {
onprogress: (index, max) => {
const fileProgress = index / max;
const globalProgress = (processed + fileProgress) / totalFiles;
progressBar.style.width = `${globalProgress * 100}%`;
progressInfo.textContent = `${Math.round(globalProgress * 100)}% ‚Äî ${safeName}`;
}
});
processed++;
const globalProgress = processed / totalFiles;
progressBar.style.width = `${globalProgress * 100}%`;
progressHeader.textContent = `Backing up: ${album.name}`;
progressInfo.textContent = `‚úÖ ${img.name} (${processed}/${totalFiles})`;
} catch (err) {
console.warn(`Failed to add ${img.name}`, err);
progressInfo.textContent = `‚ö†Ô∏è Skipped: ${img.name}`;
await new Promise(r => setTimeout(r, 300));
}
}
}
if (cancelToken.cancelled) throw new Error('Cancelled by user');
progressHeader.textContent = 'Finalizing ZIP‚Ä¶';
progressInfo.textContent = 'Writing archive‚Ä¶';
const zipBlob = await zipWriter.close();
const a = document.createElement('a');
const timestamp = new Date().toISOString().slice(0,19).replace(/[:T]/g,'-');
a.href = URL.createObjectURL(zipBlob);
a.download = `gallery1-backup-${timestamp}.zip`;
a.click();
progressHeader.textContent = '‚úÖ Backup Complete!';
progressInfo.textContent = `Saved ${totalFiles} file(s) across ${allAlbums.length} album(s).`;
cancelProgressBtn.style.display = 'none';
closeProgressBtn.style.display = 'block';
} catch (err) {
if (err.message === 'Cancelled by user') {
progressHeader.textContent = '‚ùå Cancelled';
progressInfo.textContent = 'Backup was cancelled.';
} else {
console.error('ZIP export failed', err);
progressHeader.textContent = '‚ùå Backup Failed';
progressInfo.textContent = `Error: ${err.message || 'Unknown'}`;
}
cancelProgressBtn.style.display = 'none';
closeProgressBtn.style.display = 'block';
}
}

async function restoreAllFromZip(file) {
cancelToken = { cancelled: false };
cancelProgressBtn.style.display = 'block';
closeProgressBtn.style.display = 'none';
progressTitle.textContent = 'Restoring Albums';
progressHeader.textContent = 'Reading ZIP‚Ä¶';
progressInfo.textContent = 'Parsing archive‚Ä¶';
progressBar.style.width = '0%';
progressDialog.showModal();
try {
const reader = new zip.ZipReader(new zip.BlobReader(file));
const entries = await reader.getEntries();
const fileEntries = entries.filter(e => !e.directory);
if (fileEntries.length === 0) {
alert('No files found in ZIP.');
progressDialog.close();
return;
}
let processed = 0;
const albumMap = new Map();
await ensureDefaultAlbum();
let existingAlbums = await getAllAlbums();

for (const entry of fileEntries) {
if (cancelToken.cancelled) throw new Error('Cancelled by user');
const pathParts = entry.filename.split('/');
let albumName = 'Default';
let fileName = entry.filename;
if (pathParts.length > 1) {
albumName = pathParts.slice(0, -1).join('/');
fileName = pathParts[pathParts.length - 1];
}
albumName = albumName.trim() || 'Default';
fileName = fileName.trim() || `imported-${uid()}`;
if (albumName === 'Default') albumName = 'Imported';

let albumId = albumMap.get(albumName);
if (!albumId) {
const existing = existingAlbums.find(a => a.name.toLowerCase() === albumName.toLowerCase());
if (existing) {
albumId = existing.id;
} else {
albumId = uid();
const albumRecord = {
id: albumId,
name: albumName,
createdAt: Date.now(),
imageCount: 0
};
await putAlbumRecord(albumRecord);
existingAlbums.push(albumRecord);
}
albumMap.set(albumName, albumId);
}

const existingImages = await getImageRecordsByAlbum(albumId);
const isDuplicate = existingImages.some(img => img.name === fileName && img.size === entry.uncompressedSize);

if (isDuplicate) {
    processed++;
    progressInfo.textContent = `‚è≠Ô∏è Skipped (Duplicate): ${fileName}`;
    continue;
}

progressHeader.textContent = `Restoring: ${albumName}`;
progressInfo.textContent = `üì• ${fileName} (${processed + 1}/${fileEntries.length})`;
try {
const writer = new zip.BlobWriter();
await entry.getData(writer, {
onprogress: (index, max) => {
const fileProgress = index / max;
const globalProgress = (processed + fileProgress) / fileEntries.length;
progressBar.style.width = `${globalProgress * 100}%`;
}
});
const blob = await writer.getData();
const ab = await blobToArrayBuffer(blob);
const enc = await encryptArrayBuffer(ab);
const rec = {
id: uid(),
name: fileName,
type: blob.type || 'application/octet-stream',
size: blob.size,
lastModified: Date.now(),
addedAt: Date.now(),
cipher: enc.cipher,
iv: enc.iv,
albumId: albumId
};
await putImageRecord(rec);
processed++;
const globalProgress = processed / fileEntries.length;
progressBar.style.width = `${globalProgress * 100}%`;
} catch (err) {
console.warn(`Failed to restore ${fileName}`, err);
progressInfo.textContent = `‚ö†Ô∏è Skipped: ${fileName}`;
await new Promise(r => setTimeout(r, 300));
}
}
if (cancelToken.cancelled) throw new Error('Cancelled by user');
await reader.close();
progressHeader.textContent = '‚úÖ Restore Complete!';
progressInfo.textContent = `Restored ${processed} file(s) into ${albumMap.size} album(s).`;
cancelProgressBtn.style.display = 'none';
closeProgressBtn.style.display = 'block';
await refreshDashboard();
if (currentAlbumId !== 'default') {
switchToDashboard();
}
} catch (err) {
if (err.message === 'Cancelled by user') {
progressHeader.textContent = '‚ùå Cancelled';
progressInfo.textContent = 'Restore was cancelled.';
} else {
console.error('ZIP restore failed', err);
progressHeader.textContent = '‚ùå Restore Failed';
progressInfo.textContent = `Error: ${err.message || 'Unknown'}`;
}
cancelProgressBtn.style.display = 'none';
closeProgressBtn.style.display = 'block';
}
}
async function handleImport(file, targetAlbumId = null){
try{
const text = await file.text();
const payload = JSON.parse(text);
let importedCount = 0;
if (payload.version === 2 && payload.allAlbums && payload.albums) {
for (const albumData of payload.albums) {
const newAlbumId = uid();
const albumRecord = {
id: newAlbumId,
name: albumData.albumName,
createdAt: Date.now(),
imageCount: 0
};
await putAlbumRecord(albumRecord);
for(const img of albumData.images){
const blob = await (await fetch(img.dataURL)).blob();
const ab = await blobToArrayBuffer(blob);
const enc = await encryptArrayBuffer(ab);
const rec = {
id: uid(),
name: img.name||'imported-image',
type: blob.type||img.type||'image/*',
size: blob.size||img.size,
lastModified: img.lastModified||Date.now(),
addedAt: Date.now(),
cipher: enc.cipher,
iv: enc.iv,
albumId: newAlbumId
};
await putImageRecord(rec);
importedCount++;
}
}
alert(`‚úÖ Imported ${payload.albums.length} album(s) with ${importedCount} total images.`);
await refreshDashboard();
} else if (payload.version === 2 && payload.albumName && payload.images) {
let albumId = targetAlbumId;
if (!albumId) {
const newAlbumId = uid();
const albumRecord = {
id: newAlbumId,
name: payload.albumName,
createdAt: Date.now(),
imageCount: 0
};
await putAlbumRecord(albumRecord);
albumId = newAlbumId;
}
for(const img of payload.images){
const blob = await (await fetch(img.dataURL)).blob();
const ab = await blobToArrayBuffer(blob);
const enc = await encryptArrayBuffer(ab);
const rec = {
id: uid(),
name: img.name||'imported-image',
type: blob.type||img.type||'image/*',
size: blob.size||img.size,
lastModified: img.lastModified||Date.now(),
addedAt: Date.now(),
cipher: enc.cipher,
iv: enc.iv,
albumId: albumId
};
await putImageRecord(rec);
importedCount++;
}
alert(`‚úÖ Imported ${importedCount} image(s) to album "${payload.albumName}".`);
if (currentAlbumId === albumId) refreshGalleryView();
else if (!targetAlbumId) switchToAlbum(albumId);
} else if (payload && payload.images) {
const targetId = targetAlbumId || currentAlbumId;
for(const img of payload.images){
const blob = await (await fetch(img.dataURL)).blob();
const ab = await blobToArrayBuffer(blob);
const enc = await encryptArrayBuffer(ab);
const rec = {
id: uid(),
name: img.name||'imported-image',
type: blob.type||img.type||'image/*',
size: blob.size||img.size,
lastModified: img.lastModified||Date.now(),
addedAt: Date.now(),
cipher: enc.cipher,
iv: enc.iv,
albumId: targetId
};
await putImageRecord(rec);
}
alert(`‚úÖ Imported ${payload.images.length} image(s).`);
if (currentAlbumId === targetId) refreshGalleryView();
} else {
throw new Error('Invalid file');
}
}catch(err){
console.error(err);
alert('‚ùå Import failed: '+ err.message);
}
}
function blobToDataURL(blob){
return new Promise((resolve,reject)=>{
const fr = new FileReader();
fr.onload=()=>resolve(fr.result);
fr.onerror=()=>reject(fr.error);
fr.readAsDataURL(blob);
});
}
async function ingestFiles(fileList){
const files = Array.from(fileList).filter(f=> f.type && f.type.startsWith('image/'));
if(files.length===0){
alert('Please choose image files (including GIFs).');
return;
}
for(const f of files){
const ab = await blobToArrayBuffer(f);
const enc = await encryptArrayBuffer(ab);
const rec = {
id: uid(),
name: f.name,
type: f.type,
size: f.size,
lastModified: f.lastModified,
addedAt: Date.now(),
cipher: enc.cipher,
iv: enc.iv,
albumId: currentAlbumId
};
await putImageRecord(rec);
}
refreshGalleryView();
}

fileInput.addEventListener('change', e=>{
if(e.target.files?.length) ingestFiles(e.target.files);
e.target.value='';
});
importInput.addEventListener('change', e=>{
if(e.target.files?.length) handleImport(e.target.files[0]);
e.target.value='';
});
importAlbumInput.addEventListener('change', e=>{
if(e.target.files?.length && currentActionAlbum) {
handleImport(e.target.files[0], currentActionAlbum.id);
}
e.target.value='';
});
restoreAllInput.addEventListener('change', e=>{
if(e.target.files?.length) {
const file = e.target.files[0];
if (file.name.toLowerCase().endsWith('.zip')) {
restoreAllFromZip(file);
} else {
handleImport(file);
}
}
e.target.value='';
});
dropzone.addEventListener('dragover', e=>{
e.preventDefault();
dropzone.classList.add('dragover');
});
dropzone.addEventListener('dragleave', ()=> dropzone.classList.remove('dragover'));
dropzone.addEventListener('drop', e=>{
e.preventDefault();
dropzone.classList.remove('dragover');
if(e.dataTransfer.files?.length) ingestFiles(e.dataTransfer.files);
});
selectAllBtn.addEventListener('click', async()=>{
const items = await getImageRecordsByAlbum(currentAlbumId);
selections = new Set(items.map(i=>i.id));
refreshGalleryView();
});
clearSelBtn.addEventListener('click', async()=>{
if(!selections.size) return;
if(!confirm(`Delete ${selections.size} selected item(s)?`)) return;
for(const id of selections){
await deleteImageRecord(id);
}
selections.clear();
refreshGalleryView();
});
clearAllBtn.addEventListener('click', async()=>{
if(!confirm(`Delete ALL images in this album?`)) return;
const items = await getImageRecordsByAlbum(currentAlbumId);
for (const item of items) {
await deleteImageRecord(item.id);
}
selections.clear();
refreshGalleryView();
});
exportSelBtn.addEventListener('click', async()=>{
if(selections.size) exportByIds(Array.from(selections));
});
exportAllBtn.addEventListener('click', async()=>{
const items = await getImageRecordsByAlbum(currentAlbumId);
if(items.length) exportByIds(items.map(i=>i.id));
});
newAlbumBtn.addEventListener('click', () => {
albumNameInput.value = '';
albumDialog.showModal();
});
createAlbumBtn.addEventListener('click', () => {
createAlbum(albumNameInput.value);
});
exportAlbumBtn.addEventListener('click', async () => {
if (currentActionAlbum) {
await exportAlbumById(currentActionAlbum.id);
}
albumActionsDialog.close();
});
deleteAlbumBtn.addEventListener('click', async () => {
if (currentActionAlbum && confirm(`Delete album "${currentActionAlbum.name}" and all its images?`)) {
await deleteAlbum(currentActionAlbum.id);
albumActionsDialog.close();
}
});
backupAllBtn.addEventListener('click', backupAllToZip);
refreshCacheBtn.addEventListener('click', async () => {
refreshCacheBtn.disabled = true;
refreshCacheBtn.textContent = '‚è≥ Refreshing...';
try {
await refreshAlbumCache();
await refreshDashboard();
refreshCacheBtn.textContent = '‚úÖ Cache Refreshed';
setTimeout(() => {
refreshCacheBtn.textContent = 'üîÑ Refresh Cache';
refreshCacheBtn.disabled = false;
}, 2000);
} catch (err) {
console.error('Cache refresh failed', err);
alert('Failed to refresh cache: ' + err.message);
refreshCacheBtn.textContent = 'üîÑ Refresh Cache';
refreshCacheBtn.disabled = false;
}
});
viewer.addEventListener('click', (e) => { if (e.target === viewer) viewer.close(); });
albumDialog.addEventListener('click', (e) => { if (e.target === albumDialog) albumDialog.close(); });
albumActionsDialog.addEventListener('click', (e) => { if (e.target === albumActionsDialog) albumActionsDialog.close(); });
cancelProgressBtn.addEventListener('click', () => {
cancelToken.cancelled = true;
cancelProgressBtn.disabled = true;
cancelProgressBtn.textContent = 'Cancelling‚Ä¶';
});
closeProgressBtn.addEventListener('click', () => {
progressDialog.close();
});

(async function init(){
try{
db = await openDB();
await ensureDefaultAlbum();
await ensureSaltAndKey("lkjh");
await refreshDashboard();
stats.classList.add('hidden');
}catch(err){
console.error('Init error', err);
alert('Initialization failed: '+err.message);
}
})();
</script>
</body>
</html>
